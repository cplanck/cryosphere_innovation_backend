[{"model": "documentation.documentation", "pk": 1, "fields": {"title": "Visualizing SIMB3 data using Python", "slug": "simb3-python", "path": "articles/simb3-python", "status": "Published", "internal": false, "heading": "Learn how to plot SIMB3 data using the Python", "featured": false, "featured_heading": "SIMB3 + Python", "image": "article_images/simb3_plus_python.png", "image_attribution": null, "published_date": "2022-02-20", "updated_date": "2022-02-21", "body": "<p>It's easy to create rich visualizations of ice and snow thickness, growth, melt, and temperature profile using SIMB3 data. In this tutorial, we&rsquo;ll show you how to do it in Python.</p>\r\n<h3>Before we get started, you'll need:</h3>\r\n<ul>\r\n<li>An SIMB3 datasheet (or sample below)</li>\r\n<li>A code editor of choice (we recommend <a href=\"https://code.visualstudio.com/\">Visual Studio</a>)</li>\r\n</ul>\r\n<p>If you'd like to skip the tutorial and get straight to plotting, you can download the script that we build in this tutorial here:</p>\r\n<ul>\r\n<li><a href=\"https://app.cryosphereinnovation.com/tutorials/python/massBalancePlot.py\">massBalancePlot.py</a></li>\r\n<li><a href=\"https://app.cryosphereinnovation.com/tutorials/python/SIMB3sampleDataSheet.csv\">SIMB3sampleDataSheet.csv</a></li>\r\n</ul>\r\n<p><em>Note: this tutorial assumes you have an up-to-date version of Python 3 installed on your computer and that you have basic familiarity with using a shell terminal. If you are unfamiliar with how to install or upgrade Python, <a href=\"https://realpython.com/courses/installing-python-windows-macos-linux/\">here</a> is an excellent tutorial that will walk you through how to get Python setup on MacOS, Windows, or Linux operating systems.</em><strong>&zwj;</strong>&zwj;<strong>&zwj;</strong></p>\r\n<pre class=\"language-matlab\"><code>import numpy as np\r\nimport pandas as pd\r\nfrom matplotlib import pyplot as plt   </code></pre>\r\n<h2 style=\"margin-left: 0px;\">A quick introduction</h2>\r\n<p>One of the best parts about working with SIMB3 data is that the results are highly visual. With the surface and bottom rangefinder data alone we can see how the ice (and snow!) change thickness through the season. By incorporating data from the vertical temperature string, we can examine the vertical conductive heat flux. If we combine all three measurements, we create a comprehensive picture of the ice state through time that we refer to as a plot a<em> mass balance plot</em>.&zwj;</p>\r\n<h3>The mass balance plot</h3>\r\n<p>A <em>mass balance plot</em> shows ice and snow growth, melt, and internal temperature on a single, easily understandable figure (Figure 1). On the x-axis is time and on the y-axis is thickness or depth. As the ice grows and melts, the distances recorded by the SIMB3 surface and bottom rangefinders lengthen and shorten. With a little knowledge of the <a href=\"https://www.cryosphereinnovation.com/simb3-detailed-specs\">SIMB3 dimensions</a> and the deployment conditions, we can turn these distances into ice and snow thickness values. Over time, changes in these values represent ice and snow growth and melt.</p>\r\n<p style=\"margin-left: auto;\"><img class=\"image_resized rounded-md\" style=\"width: 826px;\" src=\"https://uploads-ssl.webflow.com/5fff824073ff742b6ecd2707/60832b49bbf27d04a9e7019f_simb3_mb_plot_annotated-01.png\" alt=\"SIMB3 derived mass balance plot with snow accumulation, surface melt, bottom melt, and temperature profile descriptors\" height=\"440\"></p>\r\n<p><strong>Figure 1: </strong>From the mass balance plot you can easily determine ice growth, melt, snow accumulation, and temperature profile visually. Because SIMB3 independently measures surface and bottom position, surface and bottom melt can be distinguished.</p>\r\n<p>In this tutorial, we'll be covering how to make the plot in Figure 1 in Python.&zwj;</p>\r\n<h2>Time-series line plots</h2>\r\n<p>SIMB3 is also equipped with sensors that measure upper-ocean temperature, battery voltage, and meteorological data such as air temperature and barometric pressure. Creating these plots is straightforward compared to the mass balance plot, so we're not going to cover it in this article.</p>\r\n<h2 style=\"margin-left: 0px;\">Getting started with Python</h2>\r\n<p>Okay, let's get right into it. From the&nbsp;<a href=\"https://cryosphereinnovation.com/data\">Real Time Data portal</a>, navigate to the page for the SIMB3 which you&rsquo;d like to analyze. Click the blue &ldquo;Download CSV&rdquo; button to download the most recent datasheet for the instrument. Alternatively, you can use your own file or <a href=\"https://app.cryosphereinnovation.com/tutorials/python/SIMB3sampleDataSheet.csv\">this sample</a> for this tutorial.</p>\r\n<h2>Create a new Python file</h2>\r\n<p>Inside of your code editor or terminal, navigate to a directory where you'd like to store your files for this project. Create a new file and give it a name and .py extension. We created a directory named <code><span style=\"color: rgb(56, 56, 56);\">SIMB3_Python</span></code> and a file named <span style=\"color: rgb(56,56,56);\">massBalancePlot.py</span>. While not required, I'd recommend moving your freshly downloaded datasheet into this directory.&zwj;</p>\r\n<p>In a MacOS/Linux terminal:</p>\r\n<p>&nbsp;</p>\r\n<pre><code class=\"language-bash\">cd ~\r\nmkdir SIMB3-Python\r\ncd SIMB3-Python\r\ntouch massBalancePlot.py</code></pre>\r\n<blockquote>\r\n<p>Note that the prefix <span style=\"color: rgb(56,56,56);\">sudo</span> might be required if you are not logged in with administrative access.</p>\r\n</blockquote>\r\n<h2>Installing required libraries</h2>\r\n<p>We'll be using the Numpy, Pandas, and Matplotlib libraries to structure, manipulate, and eventually plot our data. To import them, open your Python file and add the following lines at the very top.</p>\r\n<pre><code class=\"language-python\">import numpy as np\r\nimport pandas as pd\r\nfrom matplotlib import pyplot as plt   </code></pre>\r\n<p>&zwj;</p>\r\n<p>If you haven't used any or all of these libraries before, you will need to install them. This is done simply using <span style=\"color: rgb(56,56,56);\">pip3 install</span>.</p>\r\n<pre><code class=\"language-python\">\r\npip3 install numpy pandas matplotlib\r\n </code></pre>\r\n<p>&zwj;</p>\r\n<p>With the libraries installed, it's now possible to create the functions which will layer the filled-area plots required to generate the mass balance plot.&nbsp;We'll accomplish this by making a plotting function that takes in a datasheet as input.</p>\r\n<p>&zwj;</p>\r\n<h2 style=\"margin-left: 0px;\">Creating the mass balance plot function</h2>\r\n<p>For the mass balance plot, copy the following code directly below your <span style=\"color: rgb(151,35,35);\"><code>import</code></span> statements. Don't worry, we'll explain the whole thing block-by-block below.</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-python\"><code>def plot_simb(dtc: np.ndarray, surface_distance, bottom_distance, timestamp, initial_snow_depth, distance_between_rangefinders):\r\n\r\n    #calculate height of surface rangefinder above the ice surface\r\n    height_above_ice = surface_distance[0] + initial_snow_depth\r\n\r\n    #create arrays that store values for each timestamp\r\n    snow_height = height_above_ice - surface_distance\r\n    ice_thickness = distance_between_rangefinders - height_above_ice - bottom_distance\r\n    ice_thickness = - ice_thickness #make negative for plotting because it's below waterline\r\n\r\n    #define temperature string position (height above ice)\r\n    temp_string_length = 3.84 #standard SIMB3 temperature string has 2 cm spacing and 192 thermistors\r\n    temp_string_offset = 0 #the axial distance between the surface rangefinder and the first thermister on the DTC\r\n    temp_string_top = height_above_ice - temp_string_offset #distance from the top of the ice to the first thermistor in the temperature string\r\n    temp_string_bottom = temp_string_length - temp_string_top\r\n    temp_string_bottom = temp_string_bottom * (-1) #make negative for plotting\r\n    \r\n\r\n    #shift excel serial date (1900 epoch) to the Python 1970 epoch by adding the number of days between 01/01/1900 and 01/01/1970 \r\n    #then subtract 1 to account for the famous 1900 excel leap year timestamp bug\r\n    timestamp = timestamp - 25568 - 1 \r\n    \r\n    #set plot bounds\r\n    upper_bound = 1\r\n    lower_bound = -3 \r\n    \r\n    #create mass balance plot\r\n    fig, ax = plt.subplots()\r\n    im = ax.imshow(dtc, cmap='jet', vmin=-30, vmax=0, extent=[timestamp[0], timestamp[-1], temp_string_bottom, temp_string_top],\r\n                   aspect='auto', zorder=0)     #format ice temperature heatmap from dtc (temperature string) data\r\n    plt.colorbar(im, ax=ax, label='Temperature (C)')\r\n\r\n    #color in between the lines\r\n    ax.fill_between(timestamp, snow_height, 0, color=\"grey\", zorder=1)                  #plot snow height on top of ice\r\n    ax.fill_between(timestamp, temp_string_top, snow_height, color='white', zorder=2)       #create whitespace above snow\r\n    ax.fill_between(timestamp, ice_thickness, lower_bound, color='b', zorder=3)         #plot lower boundary of ice\r\n\r\n    #bound and label y axis\r\n    ax.set_ylim(lower_bound, upper_bound)\r\n    plt.ylabel('Depth (m)')\r\n\r\n    #format x-axis as date\r\n    formatter = mdates.DateFormatter(\"%Y-%m-%d\")\r\n    ax.xaxis.set_major_formatter(formatter)\r\n\r\n    #only label each month\r\n    locator = mdates.MonthLocator()\r\n    ax.xaxis.set_major_locator(locator)\r\n\r\n    plt.show()\r\n    </code></pre>\r\n<p>Taking a look at the function declaration, we see that it takes values from the temperature string (<span style=\"color: rgb(56,56,56);\"><code>dtc: np.ndarray</code></span>), the surface rangefinder (<span style=\"color: rgb(56,56,56);\">surface_distance</span>), the bottom rangefinder (<span style=\"color: rgb(56,56,56);\"><code>bottom_distance</code></span>), the time stamp (<span style=\"color: rgb(56,56,56);\"><code>timestamp</code></span>), the initial snow depth (<span style=\"color: rgb(56,56,56);\"><code>initial_snow_depth</code></span>), and the rangefinders distance (<span style=\"color: rgb(56,56,56);\"><code>distance_between_rangefiners</code></span>) as inputs.</p>\r\n<p>&zwj;</p>\r\n<p>Of these inputs, the <span style=\"color: rgb(56,56,56);\">surface_distance</span>, <span style=\"color: rgb(56,56,56);\">bottom_distance</span>, <span style=\"color: rgb(56,56,56);\">timestamp</span> are 1D arrays of length 1 x N, where N is the length of datasheet (often the number of transmissions from the buoy). The temperature string array (<span style=\"color: rgb(56,56,56);\"><code>dtc: np.ndarray</code></span>) is 2D with a size of 192 x N. The <span style=\"color: rgb(56,56,56);\">initial_snow_depth</span> and <span style=\"color: rgb(56,56,56);\">distance_between_sounders</span> values are both scalars.</p>\r\n<p>&zwj;</p>\r\n<h4>Define reference height from ice surface</h4>\r\n<p>We tried to give the variables in this function intuitive names, but let's still go through it block-by-block to make sure there's no confusion. In the first row, we calculate the fixed distance between the surface rangefinder and the ice surface by summing the first value in the <span style=\"color: rgb(56,56,56);\">surface_distance</span> array (i.e., the value immediately after the buoy was deployed)&nbsp;and the initial snow height. You can also declare this value manually using measurements from deployment.</p>\r\n<pre><code class=\"language-python\">\r\n#calculate height of surface rangefinder above the ice surface\r\nheight_above_ice = surface_distance[0] + initial_snow_depth \r\n   </code></pre>\r\n<p>&zwj;</p>\r\n<h4>Snow height and ice thickness</h4>\r\n<p>We then create two arrays that define the snow height (i.e., the snow thickness)&nbsp;and the ice thickness. The snow height is simply the height of the surface rangefinder above the ice (does not change once the SIMB3 is frozen in) minus the reading from the surface rangefinder.</p>\r\n<pre><code class=\"language-python\">\r\n#create arrays that store values for each timestamp\r\nsnow_height = height_above_ice - surface_distance\r\nice_thickness = distance_between_rangefinders - height_above_ice - bottom_distance\r\nice_thickness = - ice_thickness #make negative for plotting because it's below waterline\r\n\r\n</code></pre>\r\n<p>&zwj;</p>\r\n<p>We then compute the ice thickness by subtracting the height of the surface rangefinder above the ice (<span style=\"color: rgb(56,56,56);\">height_above_ice</span>) and the bottom rangefinder value (<span style=\"color: rgb(56,56,56);\">bottom_distance</span> from the total distance between rangefinders, <span style=\"color: rgb(56,56,56);\">distance_between_rangefinders</span>. For a standard SIMB3, <span style=\"color: rgb(56,56,56);\">distance_between_rangefinders = </span><span style=\"color: rgb(42,161,152);\">4.051</span> meters.</p>\r\n<p>&zwj;</p>\r\n<blockquote>\r\n<p>It should be noted that the \"ice thickness\"&nbsp;variable name is slightly inaccurate; <span style=\"color: rgb(56,56,56);\">ice_thickness</span> as computed here is strictly the thickness of ice below freeboard. In the summer, surface melt will contribute to ice thickness reduction and is not captured by this variable.</p>\r\n</blockquote>\r\n<h4>&nbsp;</h4>\r\n<h4>Temperature string height reference</h4>\r\n<p>Moving along to the second block, we create several variables which define the position of the temperature string relative to the SIMB3 surface rangefinder and to the ice surface.</p>\r\n<pre><code class=\"language-python\">\r\n#define temperature string position (height above ice)\r\ntemp_string_length = 3.84 #standard SIMB3 temperature string has 2 cm spacing and 192 thermistors\r\ntemp_string_offset = 0 #the axial distance between the surface rangefinder and the first thermister on the DTC\r\ntemp_string_top = height_above_ice - temp_string_offset #distance from the top of the ice to the first thermistor in the temperature string\r\ntemp_string_bottom = temp_string_length - temp_string_top\r\ntemp_string_bottom = temp_string_bottom * (-1) #make negative for plotting\r\n\r\n</code></pre>\r\n<p>&zwj;</p>\r\n<p>The standard SIMB3 Bruncin digital temperature string is 3.84 meters long and measures temperature at 2 cm intervals along the length (192 total values). During buoy manufacturing, the position of the first thermistor is placed 0.2 cm below the surface rangefinder. After installation and freeze-in, this becomes a fixed position above the ice (<span style=\"color: rgb(56,56,56);\">temp_string_top</span>).</p>\r\n<p>&zwj;</p>\r\n<blockquote>\r\n<p>Quick note:&nbsp;the SIMB3sampleDataSheet.csv used in this tutorial was generated by a past-generation SIMB3 which had a <span style=\"color: rgb(181,137,0);\"><code>temp_string_offset</code></span><span style=\"color: rgb(56,56,56);\"><code> = </code></span><span style=\"color: rgb(42,161,152);\"><code>0</code></span>. All modern SIMB3s have a <span style=\"color: rgb(181,137,0);\"><code>temp_string_offset</code></span><span style=\"color: rgb(56,56,56);\"><code> = </code></span><span style=\"color: rgb(42,161,152);\"><code>0.2</code></span></p>\r\n</blockquote>\r\n<p>&zwj;</p>\r\n<p>The temperature string bottom (i.e., the distance between the ice surface and the final thermistor on the chain) is simply the length of the temperature string minus the height of the first thermistor above the ice surface.</p>\r\n<p>&zwj;</p>\r\n<h4>Realign Excel timestamp</h4>\r\n<p>While this is not strictly necessary, to have dates to plot along the x-axis, we need to realign the Excel serial date to the 1970 epoch used by Python. To do this, just add the number of days (including leap years!) between 01/01/1900 and 01/01/1970. Note that you must also subtract one extra day to account for the infamous Excel leap year bug. For more on how dates are handled in excel, check <a href=\"https://xlrd.readthedocs.io/en/latest/dates.html#dates-in-excel-spreadsheets\">this</a> out.</p>\r\n<pre><code class=\"language-python\">\r\n#shift excel serial date (1900 epoch) to the Python 1970 epoch by adding the number of days between 01/01/1900 and 01/01/1970 \r\n#then subtract 1 to account for the famous 1900 excel leap year timestamp bug\r\ntimestamp = timestamp - 25568 - 1 \r\n\r\n</code></pre>\r\n<p>&zwj;</p>\r\n<h4>Plot window parameters</h4>\r\n<p>Finally, we set the bounds for our plot window. For most buoys, 1 m above the ice surface and 3 meters below the surface is good.</p>\r\n<pre><code class=\"language-python\">\r\n#set plot bounds\r\nupper_bound = 1\r\nlower_bound = -3\r\n\r\n</code></pre>\r\n<p>&zwj;</p>\r\n<h4>Plot temperature string values</h4>\r\n<p>We're now ready to assemble the mass balance figure. We'll start by defining a <span style=\"color: rgb(56,56,56);\">plt.subplots()</span> object, and then we'll pass it our temperature string data.</p>\r\n<pre><code class=\"language-python\">\r\n#create mass balance plot\r\nfig, ax = plt.subplots()\r\nim = ax.imshow(dtc, cmap='jet', vmin=-30, vmax=0, extent=[timestamp[0], timestamp[-1], temp_string_bottom, temp_string_top],\r\n                   aspect='auto', zorder=0)     #format ice temperature heatmap from dtc (temperature string) data\r\nplt.colorbar(im, ax=ax)\r\n\r\n</code></pre>\r\n<p>&zwj;</p>\r\n<p>Here, the <span style=\"color: rgb(56,56,56);\"><code>imshow()</code></span> function takes in our digital temperature string array (<span style=\"color: rgb(56,56,56);\"><code>dtc</code></span>) and the bounds of the mesh over which we want to plot (in this case, on the x-axis from the first to last entry in <span style=\"color: rgb(56,56,56);\">timestamp</span> and on the y-axis from <span style=\"color: rgb(56,56,56);\">temp_string_bottom</span> to <span style=\"color: rgb(56,56,56);\">temp_string_top</span>).</p>\r\n<p>&zwj;</p>\r\n<p><span style=\"color: rgb(56,56,56);\"><code>imshow()</code></span> plots the temperature string data and <span style=\"color: rgb(56,56,56);\"><code>plt.colorbar(im, ax=ax)</code></span> adds a colorbar with bounds defined by <span style=\"color: rgb(56,56,56);\"><code>vmin</code></span> and <span style=\"color: rgb(56,56,56);\"><code>vmax</code></span>. Both <span style=\"color: rgb(56,56,56);\"><code>vmin</code></span> and <span style=\"color: rgb(56,56,56);\"><code>vmax</code></span> should be set so that they encompass any temperature value present in the temperature string array.</p>\r\n<p>&zwj;</p>\r\n<h4>Plot rangefinder values</h4>\r\n<p>As the final step in the creation of our mass balance plot function, we'll fill in the regions of our plot corresponding to air, snow, and water using the rangefinder values. This is straightforward using the <span style=\"color: rgb(56,56,56);\"><code>fill_between()</code></span> function.</p>\r\n<pre><code class=\"language-python\">\r\n#color in between the lines\r\n    ax.fill_between(timestamp, snow_height, 0, color=\"grey\", zorder=1)                  #plot snow height on top of ice\r\n    ax.fill_between(timestamp, temp_string_top, snow_height, color='white', zorder=2)       #preate whitespace above snow\r\n    ax.fill_between(timestamp, ice_thickness, lower_bound, color='b', zorder=3)         #plot lower boundary of ice\r\n       </code></pre>\r\n<p>&zwj;</p>\r\n<p>We can then set the y-limits of the plot, format the x-axis as a date, and command the plot to show when the <span style=\"color: rgb(56,56,56);\">plot_simb</span> function is called.</p>\r\n<pre><code class=\"language-python\">\r\n#bound y axis\r\nax.set_ylim(lower_bound, upper_bound)       \r\n\r\n#format x-axis as date\r\nformatter = mdates.DateFormatter(\"%Y-%m-%d\")\r\nax.xaxis.set_major_formatter(formatter)\r\n\r\n#only label each month\r\nlocator = mdates.MonthLocator()\r\nax.xaxis.set_major_locator(locator)\r\n\r\n</code></pre>\r\n<p>&zwj;</p>\r\n<h4>Calling the mass balance plot function</h4>\r\n<p>To call our mass balance plot, we need to parse our CSV datasheet and pass the required parameters into the <span style=\"color: rgb(56,56,56);\"><code>plot_simb()</code></span> function. To do this, let's make an another function that takes our data path, initial snow depth, and plot range in as arguments and then calls <span style=\"color: rgb(56,56,56);\"><code>plot_simb()</code></span>.</p>\r\n<pre><code class=\"language-python\">\r\ndef plot_from_csv(path_to_data: str, initial_snow_depth: float, plot_range):\r\n\r\n    #try to read csv at input location\r\n    try:\r\n        simb_df = pd.read_csv(path_to_data,skiprows=plot_range[0], nrows=plot_range[1])      #create pandas dataframe from csv\r\n        timestamp = simb_df.time_stamp.to_numpy()       #extracts time stamp from simb_df dataframe, converts to numpy array\r\n    except FileNotFoundError:\r\n        print('Invalid Path, please check file location.')\r\n        return\r\n\r\n    # Distance between sounders in meters, used for bounding the Ice Mass Balance Plot\r\n    sounder_dist = 4.051\r\n\r\n    # Extract relevant data from dataframe, convert to numpy array\r\n    snow_dist = simb_df.surface_distance.to_numpy()                     # distance from upper sounder to snow\r\n    water_depth = simb_df.bottom_distance.to_numpy()                    # distance from lower sounder to bottom of ice\r\n    dtc_values = simb_df.filter(like='dtc_values_').to_numpy().T        # temperature string data at 2 cm intervals\r\n\r\n    # Call plot function for ice mass balance plot\r\n    plot_simb(dtc_values, snow_dist, water_depth, timestamp, initial_snow_depth, sounder_dist)\r\n    \r\n</code></pre>\r\n<p>This function just extracts data from our datasheet as Pandas dataframes and passes it to our <span style=\"color: rgb(56,56,56);\">plot_simb()</span> function. When using it, the only thing to watch out for is the <span style=\"color: rgb(56,56,56);\">plot_range</span> parameter which cannot be longer than our datasheet (i.e., it cannot have more rows than our datasheet).</p>\r\n<p>&nbsp;</p>\r\n<p>As the final line in our script, we call our our <span style=\"color: rgb(56,56,56);\">plot_from_csv()</span> function. For the SIMB3sampleDataSheet.csv used in this tutorial, we'll use 0.2 m as the <span style=\"color: rgb(56,56,56);\">initial_snow_depth</span> and [0 3378] as the <span style=\"color: rgb(56,56,56);\">plot_range</span>. Note:&nbsp;you'll need to use the correct path to your datasheet if it's not in your working directory.</p>\r\n<pre><code class=\"language-python\">\r\nplot_from_csv(r'SIMB3sampleDataSheet.csv', .2, [0, 3378])\r\n\r\n</code></pre>\r\n<p>&zwj;</p>\r\n<h4 style=\"margin-left: 0px;\">Running the script</h4>\r\n<p>To run the script and create the plot, go back to your terminal and run:</p>\r\n<pre><code class=\"language-python\">\r\npython3 massBalancePlot.py\r\n\r\n</code></pre>\r\n<p>You should see the plot in Figure 2 appear.</p>\r\n<p>&zwj;</p>\r\n<p style=\"margin-left: auto;\"><img class=\"image_resized\" style=\"width: 800px;\" src=\"https://uploads-ssl.webflow.com/5fff824073ff742b6ecd2707/607df54af4c1d60407942c38_simb3_mb_plot_orig.png\" alt=\"SIMB3 derived mass balance plot\"></p>\r\n<p><strong>Figure 2: </strong>Our final mass balance plot, generated using entirely open-source software (Python and Matplotlib).</p>\r\n<p>&zwj;</p>\r\n<p>Just like that, we've created a mass balance plot from SIMB3 data using Python! Because we build this script using functions, it's easy to call for multiple SIMB3 datasets or for multiple iterations of the same dataset.</p>\r\n<p>I hope you found this tutorial helpful, and if you have any questions please reach out and we'll get back to you as soon as we can!</p>\r\n<p>Lastly, if Python isn't your jam, check out our other tutorial on how to <a href=\"https://www.cryosphereinnovation.com/articles/simb3-matlab\">Visualize SIMB3 data using Matlab</a>.</p>"}}, {"model": "documentation.documentation", "pk": 2, "fields": {"title": "Visualizing SIMB3 data using MATLAB", "slug": "coding-with-matlab", "path": "articles/coding-with-matlab", "status": "Published", "internal": false, "heading": "Learn how to plot SIMB3 data using MATLAB", "featured": false, "featured_heading": "SIMB3 + Matlab", "image": "article_images/simb3_plus_matlab-01.jpg", "image_attribution": null, "published_date": "2021-02-20", "updated_date": "2022-03-11", "body": "<p>MATLAB is the programming language of choice for many scientists, engineers, and students. In this tutorial, we'll show you how to use it to create rich visualizations of ice thickness, growth, melt and temperature from SIMB3 data.</p>\r\n<p><strong>Before we get started, you'll need:</strong></p>\r\n<ul>\r\n<li>An SIMB3 data sheet (or sample below)</li>\r\n<li>MATLAB (this tutorial is verified back to at least version R2017b)</li>\r\n</ul>\r\n<p>If you'd like to skip the tutorial and get straight to plotting, you can download the function and file that we build in this tutorial here:&nbsp;</p>\r\n<ul>\r\n<li><a href=\"https://app.cryosphereinnovation.com/tutorials/matlab/massBalancePlotF.m\">massBalancePlotF.m</a></li>\r\n<li><a href=\"https://app.cryosphereinnovation.com/tutorials/matlab/massBalancePlot.m\">massBalancePlot.m</a></li>\r\n<li><a href=\"https://app.cryosphereinnovation.com/tutorials/matlab/SIMB3sampleDataSheet.csv\">SIMB3sampleDataSheet.csv</a></li>\r\n</ul>\r\n<h2 style=\"margin-left: 0px;\">A quick introduction</h2>\r\n<p>One of the best parts about working with SIMB3 data is that the results are highly visual. With the surface and bottom rangefinder data alone we can see how the ice (and snow!) change thickness through the season. By incorporating data from the vertical temperature string, we can examine the vertical conductive heat flux. If we combine all three measurements, we create a comprehensive picture of the ice state through time that we refer to as a<em> mass balance plot</em>.</p>\r\n<h3>The mass balance plot</h3>\r\n<p>A <em>mass balance plot</em> shows ice and snow growth, melt, and internal temperature on a single, easily understandable figure (Figure 1). On the x-axis is time and on the y-axis is thickness or depth. As the ice grows and melts, the distances recorded by the SIMB3 surface and bottom rangefinders lengthen and shorten. With a little knowledge of the <a href=\"https://www.cryosphereinnovation.com/simb3-detailed-specs\">SIMB3 dimensions</a> and the deployment conditions, we can turn these distances into ice and snow thickness values. Over time, changes in these values represent ice and snow growth and melt.</p>\r\n<p>&nbsp;</p>\r\n<figure class=\"image image_resized\" style=\"width: 906px;\"><img src=\"https://nyc3.digitaloceanspaces.com/ci-webapp-space/media/django-summernote/2022-05-02/4fb86005-a055-4fe3-a1a2-f9c6e7ac4685.png\" width=\"685\" height=\"366\">\r\n<figcaption><strong>Figure 1</strong>: From the mass balance plot you can easily determine ice growth, melt, snow accumulation, and temperature profile visually. Because SIMB3 independently measures surface and bottom position, surface and bottom melt can be distinguished.</figcaption>\r\n</figure>\r\n<figure class=\"image image_resized\" style=\"width: 906px;\">In this tutorial, we'll be covering how to make the plot in Figure 1 using MATLAB.&nbsp;</figure>\r\n<h3>Time-series line plots</h3>\r\n<p>SIMB3 is also equipped with sensors that measure upper-ocean temperature, battery voltage, and meteorological data such as air temperature and barometric pressure. Creating these plots is straightforward compared to the mass balance plot, so we're not going to cover it in this article.</p>\r\n<h2 style=\"margin-left: 0px;\">Creating the mass balance plot function</h2>\r\n<p>Okay, let's jump right into it. We're going to start by creating a function that takes in data and creates the filled-layer mass balance plot. We'll then create a script file that calls our function, passing it data from the the SIMB3 datasheet.&zwj;</p>\r\n<p>To create the mass balance plot function, create a new MATLAB file and name it massBalancePlotF.m. Open the file, and paste the following code into it. Don't worry, we'll explain this block-by-block below.</p>\r\n<pre class=\"language-matlab\"><code>function []=massBalancePlotF(dtc, surface_distance, bottom_distance, time_stamp, initial_snow_depth, distance_between_rangefinders)\r\n     %% THIS FUNCTION CREATES AN SIMB3 ICE MASS BALANCE PLOT\r\n      \r\n    %transpose arrays for plotting\r\n    dtc=dtc';\r\n    surface_distance=surface_distance';\r\n    bottom_distance=bottom_distance';\r\n    time_stamp = time_stamp';\r\n     \r\n    %get length of datasheet\r\n    [~,n]=size(dtc);\r\n    %define surface rangefinder height above ice and snow height from first rangefinder reading\r\n    height_above_ice=surface_distance(1) + initial_snow_depth;\r\n    snow_height=height_above_ice - surface_distance;\r\n    %realign x-axis as serial dates proleptic ISO calendar (days since\r\n    %00-Jan-000)\r\n    x=datetime(time_stamp,'ConvertFrom','excel');\r\n    x=datenum(x);\r\n    %define temperature string position (height above ice)\r\n    temp_string_length = 3.84; %standard SIMB3 temperature string has 2 cm spacing and 192 thermistors\r\n    temp_string_offset = 0; %the axial distance between the surface rangefinder and the first thermistor on the DTC\r\n    temp_string_top = height_above_ice - temp_string_offset;\r\n    temp_string_bottom = temp_string_length - temp_string_top;\r\n    temp_string_bottom = -temp_string_bottom; %make negative for plotting\r\n    %create y-axis spacing from first thermistor to last thermistor\r\n    y=linspace(temp_string_top,temp_string_bottom,192);\r\n    %generate mesh for temperature string plotting\r\n    [X,Y]=meshgrid(x,y);\r\n     \r\n    %plot temperature string\r\n    figure('DefaultAxesFontSize',14)\r\n    pcolor(X,Y,dtc), hold on\r\n    shading interp, colormap jet\r\n    caxis([-40 0])\r\n    cb=colorbar;\r\n    cb.Location='eastoutside';\r\n    %color area between ice surface and snow height\r\n    patch([x, fliplr(x)], [snow_height, 0*ones(1,n)], [125 125 125]/255,'EdgeColor',[125 125 125]/255)\r\n    %color area between snow height and upper plot boundary\r\n    patch([x, fliplr(x)], [snow_height, fliplr(2*ones(1,n))], 'white','EdgeColor','white','LineWidth',2)\r\n    %color area between bottom position and lower plot boundary\r\n    ice_thickness = distance_between_rangefinders - height_above_ice - bottom_distance;\r\n    patch([x, fliplr(x)], [-ice_thickness, fliplr(-3*ones(1,n))], 'blue','EdgeColor','blue','LineWidth',4)\r\n    %format axes\r\n    clabel = get(cb,'YTickLabel');\r\n    clabel = strcat(clabel,'{\\circ}C');\r\n    set(cb,'YTickLabel',clabel);\r\n    ylabel('Depth')\r\n    set(gca, 'LineWidth', 3);\r\n    %convert x-axis labels to dates\r\n    num_ticks = 4;\r\n    L = get(gca,'XLim');\r\n    set(gca,'XTick',linspace(L(1),L(2),num_ticks))\r\n    datetick('x', 'yyyy-mm-dd','keepticks');</code></pre>\r\n<p>Looking at the function declaration, we see it takes a 2D array of temperature string data (<span style=\"color: rgb(56,56,56);\"><code>dtc</code></span>), 1D arrays of surface rangefinder readings (<span style=\"color: rgb(56,56,56);\"><code>surface_distance</code></span>), bottom rangefinder readings (<span style=\"color: rgb(56,56,56);\">bottom_distance</span>), and timestamps (<span style=\"color: rgb(56,56,56);\"><code>time_stamp</code></span>). It also takes a scalar values of the deployment snow depth (<span style=\"color: rgb(56,56,56);\"><code>initial_snow_depth</code></span>) and the fixed distance between the SIMB3 surface and bottom rangefinders (<span style=\"color: rgb(56,56,56);\"><code>distance_between_rangefinders</code></span>).</p>\r\n<p>With exception of the deployment snow depth and the SIMB3 rangefinder distance values, each one of these arrays is taken directly from the labeled column of the SIMB3 datasheet. For a detailed explanation of the SIMB3 datasheet, see <a href=\"https://www.cryosphereinnovation.com/articles/getting-started-with-the-simb3-datasheet\">Getting started with the SIMB3 datasheet</a>.</p>\r\n<p>&zwj;</p>\r\n<h4>Preparing the arrays</h4>\r\n<p>In the first block of this function, we take each of our arrays and transpose their rows and columns. This reshapes the 1D arrays into row vectors of length N, where N&nbsp;is the number of entries in the SIMB3 datasheet that we wish to plot For the 2D DTC array, each row represents a reading from one thermistor on the DTC. A column is a collection of DTC readings (192 in total) along the buoy length at one point in time.</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%transpose arrays for plotting\r\n    dtc=dtc';\r\n    surface_distance=surface_distance';\r\n    bottom_distance=bottom_distance';\r\n    time_stamp = time_stamp';\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: rgb(104,102,102);\">We then find the length of our dataset, which we'll use later when creating our filled plots.</span></p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%get length of datasheet\r\n    [~,n]=size(dtc);\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h4>Define reference height from ice surface</h4>\r\n<p>In the next block, we create one scalar and two arrays that define the snow height (i.e., the snow thickness) and the ice thickness. The scalar value <span style=\"color: rgb(56,56,56);\">height_above_ice</span> sets the buoy floatation height (the distance between the surface rangefinder and the ice surface). Here we calculate it as the first surface rangefinder reading plus the snow height at deployment, but it can also be set manually. Often, this value is constant across SIMB3s, but variations in water density (especially between fresh and saltwater ) will cause SIMB3s to float at different heights during deployment and freeze-in.</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%define surface rangefinder height above ice, snow height from first rangefinder reading, and ice thickness\r\n    height_above_ice=surface_distance(1) + initial_snow_depth;\r\n    snow_height=height_above_ice - surface_distance;\r\n    ice_thickness = distance_between_rangefinders - height_above_ice - bottom_distance;\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: rgb(104,102,102);\">After the floatation height is established, the time-series array of snow height can be determined. We also calculate ice thickness by subtracting the floatation height and the bottom rangefinder distance from the distance between the surface and bottom rangefinders. For a standard SIMB3, </span><span style=\"color: rgb(181,137,0);\"><code>distance_between_rangefinders</code></span><span style=\"color: rgb(56,56,56);\"><code> = </code></span><span style=\"color: rgb(42,161,152);\"><code>4.051</code></span><span style=\"color: rgb(104,102,102);\"> meters.</span></p>\r\n<p>&nbsp;</p>\r\n<blockquote>\r\n<p><span style=\"color: rgb(104,102,102);\">It should be noted that the \"ice thickness\" variable name is slightly inaccurate; </span><span style=\"color: rgb(56,56,56);\"><code>ice_thickness</code></span><span style=\"color: rgb(104,102,102);\"> as computed here is strictly the thickness of ice below freeboard. In the summer, surface melt will contribute to ice thickness reduction that is not captured by this variable.</span></p>\r\n</blockquote>\r\n<p>&nbsp;</p>\r\n<h4>Realign Excel timestamp</h4>\r\n<p>To plot dates along the x-axis, we need to realign the Excel serial date to the proleptic ISO calendar used by MATLAB (days since 00-Jan-0000). Fortunately, MATLAB&nbsp;has a built-in function that makes this easy.</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%realign x-axis as serial dates to proleptic ISO calendar (days since 00-Jan-0000)\r\n    x=datetime(time_stamp,'ConvertFrom','excel');\r\n    x=datenum(x);\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>We then convert our <span style=\"color: rgb(56,56,56);\">x</span> domain array to a <span style=\"color: rgb(56,56,56);\">datenum</span>, which we can later convert to a date string when we generate our plots.&zwj;</p>\r\n<p>&nbsp;</p>\r\n<h4>Temperature string height reference</h4>\r\n<p>Moving along to the third block, we create several variables which define the position of the temperature string relative to the SIMB3 surface rangefinder and ice surface.</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%define temperature string position (height above ice)\r\n    temp_string_length = 3.84; %standard SIMB3 temperature string has 2 cm spacing and 192 thermistors\r\n    temp_string_offset = 0; %the axial distance between the surface rangefinder and the first thermistor on the DTC\r\n    temp_string_top = height_above_ice - temp_string_offset;\r\n    temp_string_bottom = temp_string_length - temp_string_top;\r\n    temp_string_bottom = -temp_string_bottom; %make negative for plotting\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: rgb(104,102,102);\">The standard SIMB3 Bruncin digital temperature string is 3.84 meters long and measures temperature at 2 cm intervals along the length (192 total values). During buoy manufacturing, the position of the first thermistor is placed 0.2 cm below the surface rangefinder. After installation and freeze-in, this becomes a fixed position above the ice (</span><span style=\"color: rgb(56,56,56);\"><code>temp_string_top</code></span><span style=\"color: rgb(104,102,102);\">).</span></p>\r\n<p>&nbsp;</p>\r\n<blockquote>\r\n<p><span style=\"color: rgb(104,102,102);\">Quick note:&nbsp;the SIMB3sampleDataSheet.csv used in this tutorial was generated by a past-generation SIMB3 which had a </span><span style=\"color: rgb(181,137,0);\"><code>temp_string_offset</code></span><span style=\"color: rgb(56,56,56);\"><code> = </code></span><span style=\"color: rgb(42,161,152);\"><code>0</code></span><span style=\"color: rgb(104,102,102);\">. All modern SIMB3s have a </span><span style=\"color: rgb(181,137,0);\"><code>temp_string_offset</code></span><span style=\"color: rgb(56,56,56);\"><code> = </code></span><span style=\"color: rgb(42,161,152);\"><code>0.2</code></span></p>\r\n</blockquote>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: rgb(104,102,102);\">The temperature string bottom (i.e., the distance between the ice surface and the final thermistor on the chain) is simply the length of the temperature string minus the height of the first thermistor above the ice surface.</span></p>\r\n<p>&nbsp;</p>\r\n<h4>Plot temperature string values</h4>\r\n<p>As the last step before we can plot the temperature string values, we need to create a vector to represent the vertical spacing of the DTC. To do this, create a vector spanning from <span style=\"color: rgb(56,56,56);\"><code>temp_string_top</code></span> to <span style=\"color: rgb(56,56,56);\"><code>temp_string_bottom</code></span> with 192 values. Then, create a 2D array of x &amp; y&nbsp;pairs using <span style=\"color: rgb(220,50,47);\"><code>meshgrid</code></span><span style=\"color: rgb(56,56,56);\"><code>()</code></span>.</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%create y-axis spacing from first thermistor to last thermistor\r\n    y=linspace(temp_string_top,temp_string_bottom,192);\r\n    %generate mesh for temperature string plotting\r\n    [X,Y]=meshgrid(x,y);\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>We can then call <span style=\"color: rgb(56,56,56);\"><code>pcolor()</code></span>, passing it our 2D arrays X, Y, and DTC as arguments.</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%plot temperature string\r\n    figure('DefaultAxesFontSize',14)\r\n    pcolor(X,Y,dtc), hold on\r\n    shading interp, colormap jet\r\n    caxis([-40 0])\r\n    cb=colorbar;\r\n    cb.Location='eastoutside';\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h4>Plot rangefinder values</h4>\r\n<p>MATLAB makes it quite easy to add filled-area regions representing the SIMB3 surface and bottom rangefinder measurements. While there are several ways to do it, we'll do it using the <span style=\"color: rgb(56,56,56);\"><code>patch()</code></span> function which creates polygons from lists of x and y coordinates. Note that the first elements in the x and y arguments correspond to the boundary that we want to plot (snow height, ice thickness, etc.) and the second elements correspond to the location that we'd like to plot <em>up</em> or <em>down</em> to.</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%color area between ice surface and snow height\r\n    snow_color = [125 125 125]/255; %grey\r\n    patch([x, fliplr(x)], [snow_height, zeros(1,n)], snow_color,'EdgeColor',snow_color)\r\n    %color area between snow height and upper plot boundary\r\n    patch([x, fliplr(x)], [snow_height, fliplr(2*ones(1,n))], 'white','EdgeColor','white','LineWidth',2)\r\n    %color area between bottom position and lower plot boundary\r\n    patch([x, fliplr(x)], [-ice_thickness, fliplr(-3*ones(1,n))], 'blue','EdgeColor','blue','LineWidth',4)\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>We can then format the axes and convert the x-axis to a date using <span style=\"color: rgb(56,56,56);\"><code>datetick()</code></span></p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%format axes\r\n    clabel = get(cb,'YTickLabel');\r\n    clabel = strcat(clabel,'{\\circ}C');\r\n    set(cb,'YTickLabel',clabel);\r\n    ylabel('Depth')\r\n    set(gca, 'LineWidth', 3);\r\n    %convert x-axis labels to dates\r\n    num_ticks = 4;\r\n    L = get(gca,'XLim');\r\n    set(gca,'XTick',linspace(L(1),L(2),num_ticks))\r\n    datetick('x', 'yyyy-mm-dd','keepticks');\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<h2 style=\"margin-left: 0px;\">&nbsp;</h2>\r\n<h2 style=\"margin-left: 0px;\">Calling the Mass Balance Plot Function</h2>\r\n<p>To call our <span style=\"color: rgb(56,56,56);\"><code>massBalancePlotF()</code></span> function, create a new file and name it <span style=\"color: rgb(56,56,56);\">massBalancePlot.m</span>. Open the file, and add the following code:&nbsp;</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>clear;clc;close all\r\n    %import datasheet\r\n    data = csvread('path/to/your/data/SIMB3sampleDataSheet.csv',1);\r\n    %specify rows of datasheet you want to plot\r\n    range = (1:3378);\r\n    data = data(range,:);\r\n    %parse data by sensor\r\n    time_stamp = data(:,3);\r\n    dtc = data(:,18:end);\r\n    surface_distance =  smoothdata(data(:,10),'rlowess',4);\r\n    bottom_distance = data(:,8);\r\n    %define distance between rangefinders\r\n    distance_between_rangefinders = 4.051; %m\r\n    %add initial snow depth from deployment notes\r\n    initial_snow_depth = 0.2;\r\n    %call massBalancePlotF function\r\n    massBalancePlotF(dtc, surface_distance, bottom_distance, time_stamp, initial_snow_depth, distance_between_rangefinders)\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: rgb(104,102,102);\">In this code, we first import our data sheet using </span><span style=\"color: rgb(56,56,56);\"><code>csvread()</code></span><span style=\"color: rgb(104,102,102);\"> and a path to our datasheet. We then specify the rows in our datasheet that we want to use to build our mass balance plot.</span></p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%specify rows of datasheet you want to plot\r\n    range = (1:3378);\r\n    data = data(range,:);\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<blockquote>\r\n<p><span style=\"color: rgb(104,102,102);\">Note:&nbsp;you'll need to replace the </span><span style=\"color: rgb(31,184,38);\">'path/to/your/data/SIMB3sampleDataSheet.csv'</span><span style=\"color: rgb(104,102,102);\"> with the actual path to the SIMB3 datasheet you'd like to plot. The \"1\" at the end of </span><span style=\"color: rgb(56,56,56);\"><code>csvread()</code></span><span style=\"color: rgb(104,102,102);\"><code> </code>just tells the function to disregard the header.</span></p>\r\n</blockquote>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: rgb(104,102,102);\">In the second block, we parse our data array for input to our </span><span style=\"color: rgb(56,56,56);\"><code>massBalancePlotF()</code></span><span style=\"color: rgb(104,102,102);\"> function. We also define the deployment snow height and the distance between the SIMB3 rangefinders.</span></p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%parse data by sensor\r\n    time_stamp = data(:,3);\r\n    dtc = data(:,18:end);\r\n    surface_distance =  smoothdata(data(:,10),'rlowess',4);\r\n    bottom_distance = data(:,8);\r\n    %define distance between rangefinders\r\n    distance_between_rangefinders = 4.051; %m\r\n    %add initial snow depth from deployment notes\r\n    initial_snow_depth = 0.2;\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: rgb(104,102,102);\">Lastly, we call our </span><span style=\"color: rgb(56,56,56);\"><code>massBalancePlotF()</code></span><span style=\"color: rgb(104,102,102);\"> function and pass it our newly defined arguments.</span> &nbsp; &nbsp;</p>\r\n<pre class=\"language-matlab\" tabindex=\"0\"><code>%call massBalancePlotF function\r\n    massBalancePlotF(dtc, surface_distance, bottom_distance, time_stamp, initial_snow_depth, distance_between_rangefinders)\r\n    </code></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>After running the program, you should see the following plot pop up:</p>\r\n<p>&nbsp;</p>\r\n<figure class=\"image image_resized\" style=\"width: 906px;\"><img src=\"https://nyc3.digitaloceanspaces.com/ci-webapp-space/media/django-summernote/2022-05-02/d29fca45-d75b-4b21-be81-36ba68282995.png\"></figure>\r\n<p>Just like that, we've created a mass balance plot using MATLAB. Additionally, because we created a plotting function, running this for many SIMB3s is as simple as placing it in a loop and feeding it multiple datasheets.</p>\r\n<p>We covered a lot in this tutorial, but I hope you found it useful. If you have any questions or concerns, please reach out and we'll get back to you as soon as we can.</p>\r\n<p>If you don't have access to MATLAB, or if you're more of an open-source kind of person, check out our tutorial on <a href=\"https://www.cryosphereinnovation.com/articles/simb3-python\">Visualizing SIMB3 data using Python</a>!</p>"}}, {"model": "documentation.documentation", "pk": 3, "fields": {"title": "Evaluating SIMB3 for your project", "slug": "evaluating-simb3-for-your-project", "path": "articles/evaluating-simb3-for-your-project", "status": "Published", "internal": false, "heading": "See if SIMB3s unique features make it a suitable tool for your observational campaign", "featured": false, "featured_heading": "One tool, many use cases", "image": "article_images/arctic_sea_ice_svalbard.jpg", "image_attribution": null, "published_date": "2021-04-21", "updated_date": "2022-03-15", "body": "<p>Curious about whether SIMB3 will suit your project&rsquo;s needs? In this article, we&rsquo;ll discuss some of the features and use cases of the SIMB3 technology. By the end, hopefully you'll have a better idea about what SIMB3 does and how it could benefit or enable your research observational program.</p>\n<p>Let&rsquo;s start by answering the (maybe not so obvious) question. What does Seasonal Ice Mass Balance Buoy 3 do?</p>\n<p>In short, SIMB3 is an automated ice thickness gauge, ablation stake, and weather station. After being frozen into sea, pond, or lake ice, SIMB3 measures how the surrounding ice and snow change thickness through time. On predefined intervals, SIMB3 collects data and transmits it over the Iridium satellite constellation. The data is then processed and hosted to the Cryosphere Innovation cloud where it is made instantly available via our Real Time Data Portal. Iridium connectivity makes SIMB3 operable in any floating-ice environment on Earth, so long as it has a clear view of the sky.</p>\n<h3>What makes SIMB3 unique?</h3>\n<p>A defining feature of SIMB3 is that it is able to distinguish ice growth, snow accumulation, and melt. Through the use of ice-facing acoustic rangefinders, SIMB3 can identify surface and bottom melt independently, even when the ice is warm and melting. Scientifically, this feature enables changes in ice thickness to be attributed to oceanic (bottom melt) or atmospheric (surface melt) driven heat fluxes.</p>\n<p>In addition to ice growth and melt measurement, every SIMB3 is also equipped with a suite of additional sensors that record other important environmental data. These sensors include a high-resolution vertical temperature string, air temperature and barometric pressure sensors, and a GPS. We&rsquo;ve also equipped a custom SIMB3 with incident, reflected, and transmitted pyranometers, and are developing a version with sensors to measure the vertical profile of visible light. To learn more about the standard SIMB3 sensor package, check out this SIMB3 detailed specifications page.</p>\n<figure class=\"image image_resized image-style-side\" style=\"width: 34.86%;\"><img src=\"https://nyc3.digitaloceanspaces.com/ci-webapp-space/media/django-summernote/2022-02-22/f865c7ed-342e-405f-b86a-ff2e3eb84edd.jpg\" width=\"859\" height=\"1145\">\n<figcaption><strong>Figure 1</strong>: An SIMB3 installed during MOSAIC. During MOSAiC, the ability of SIMB3 to survive harsh sea-ice dynamics was put to the test. Photo courtesy of Ryleigh Moore.</figcaption>\n</figure>\n<h2>Example use case: Arctic sea ice</h2>\n<p>To help you evaluate if SIMB3 is the right tool for your project, let&rsquo;s profile one of the most common use cases: the study of sea ice mass balance in the Arctic.</p>\n<p>As climate change progresses, mitigation strategies and adaption plans rely on accurate modeling of the global climate system. Improving climate models requires better representing sea ice, which in turn requires improving knowledge of how sea ice responds to environmental forcing. Since the deployment of the first prototype in 2017, SIMB3s have provided ground-truth observations of sea ice growth and melt through time (i.e., the mass balance evolution). Because SIMB3 independently measures surface and bottom melt, observed change can be attributed to the ocean or the atmosphere. Data from many National Science Foundation funded SIMB3s is made available for researchers through our Real Time Data Portal and also through the International Arctic Buoy Program.</p>\n<p>While Arctic sea ice mass balance observation is a common use case for SIMB3, it is far from the only one. SIMB3s have been used to measure ice in shallow freshwater ponds, in landfast ice, and even in Antarctic sea ice. While each of these use cases presents different challenges and requirements, they all benefit from SIMB3s design heritage as a tool made to survive year-long campaigns in the high Arctic.</p>\n<h2>What are SIMB3's key features?</h2>\n<p>So now that we&rsquo;ve covered a common use case, let&rsquo;s talk about some of the features that you might like to know when evaluating SIMB3 for your own research project.&nbsp;&nbsp;</p>\n<h3>Direct measurement of snow/ice interface</h3>\n<p>By using acoustic rangefinders to directly measure ice/snow interfaces, SIMB3 can observe ice thickness, growth, and melt even when the ice is warm and melting. This has advantage over other temperature string methods which struggle to detect thermodynamic interfaces in the absence of a strong temperature gradient.</p>\n<h3>Open-water operable</h3>\n<p>Built as fully-contained spar-type buoy, SIMB3 is buoyant, waterproof, and able to be operated or deployed in open water. This feature gives you freedom to conduct your research program as you see fit and without the constraints of ice-based equipment.</p>\n<h3>Real-time connected</h3>\n<p>SIMB3 gives you access to ice thickness, growth, melt, temperature, and location data in real-time. You can access your data via our Real Time Data Portal, or you can build your own applications that compile or present your data on your own webpage. No matter how you do it, your data will be there within 5 minutes of transmission.</p>\n<h3>Deploy in &lt; 30 minutes</h3>\n<p>When you&rsquo;re on the ice and in the cold, you need equipment that works with you, not against you. We&rsquo;ve designed SIMB3 to be deployed in less than 30 minutes by one person without tools. To see how it&rsquo;s done, check out this video or take a peek at the SIMB3 Deployment Manual.</p>\n<h3>Is SIMB3 right for your research project?</h3>\n<p>SIMB3 is a multi-purpose ice-observational tool that was designed to survive the harshest Arctic conditions for months or years without intervention. In addition to Arctic sea ice measurement, it&rsquo;s found use in landfast ice, pond ice, and Antarctic ice. Whether it&rsquo;s the correct tool for your project of course depends on many variables, but we hope that after this article you are better informed about the features and past use cases. If you have questions or need help deciding if SIMB3 is right for you, please contact us and we'll get back to you ASAP!</p>"}}, {"model": "documentation.documentation", "pk": 4, "fields": {"title": "See an SIMB3 deployed on MOSAiC", "slug": "simb3-deployed-on-mosaic", "path": "articles/simb3-deployed-on-mosaic", "status": "Published", "internal": false, "heading": "See how to assemble, activate, and deploy an SIMB3 in < 30 minutes", "featured": false, "featured_heading": "SIMB3 a staple at Mosaic", "image": "article_images/ryleigh_with_simb3_2.jpg", "image_attribution": "Ryleigh Moore", "published_date": "2021-04-21", "updated_date": null, "body": "<h2>About the video</h2>\n<p>The&nbsp;<a href=\"https://mosaic-expedition.org/\">Multidisciplinary drifting Observatory for the Study of Arctic Climate</a> (MOSAiC) was a yearlong expedition into the Central Arctic that ran from September 2019 &ndash; October 2020. During this record-setting expedition, four Cryosphere Innovation <a href=\"../../SIMB3\">Seasonal Ice Mass Balance buoys</a> (SIMB3s) were deployed as part of a distributed network of instruments that surrounded German icebreaker Polarstern.</p>\n<p>In this video, University of Utah PhD student <a href=\"http://www.math.utah.edu/~rmoore/MOSAiC.html\">Ryleigh Moore</a> walks through how to deploy an SIMB3 at one of the MOSAiC distributed network sites.</p>\n<h3>What you&rsquo;ll learn</h3>\n<ul>\n<li>How to unbox SIMB3</li>\n<li>How to activate SIMB3 and confirm transmission to Iridium</li>\n<li>How to properly assemble SIMB3</li>\n<li>How to install SIMB3 into the ice hole<br>&nbsp;</li>\n</ul>\n<p>For more technical information about SIMB3, check out the <a href=\"../../simb3-tech-specs\">SIMB3 detailed specifications</a> page. &nbsp;</p>\n<div class=\"raw-html-embed\">\n<div class=\"d-flex justify-content-center\"><iframe title=\"YouTube video player\" src=\"https://www.youtube.com/embed/Arq1IuPwgfY\" width=\"80%\" height=\"500\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"allowfullscreen\"></iframe></div>\n</div>\n<h2>Acknowledgements</h2>\n<p><br>We are grateful to Ryleigh Moore of the University of Utah for preparing this video. The SIMB3s deployed during MOSAiC were funded by the National Science Foundation [grant #: 1724424]</p>\n<h2>Resources</h2>\n<p><br>The view or download the data from the MOSAiC SIMB3s, follow the links below:</p>\n<ul>\n<li><a>MOSAiC #1</a></li>\n<li><a>MOSAiC #2</a></li>\n<li><a>MOSAiC #3</a></li>\n<li><a>MOSAiC #4</a></li>\n</ul>"}}, {"model": "documentation.documentation", "pk": 5, "fields": {"title": "The SIMB3 datasheet", "slug": "getting-started-with-the-simb3-datasheet", "path": "articles/getting-started-with-the-simb3-datasheet", "status": "Published", "internal": false, "heading": "Everything you need to know about the SIMB3 datasheet.", "featured": false, "featured_heading": null, "image": "article_images/interpreting_SIMB3_data_1.jpg", "image_attribution": null, "published_date": "2021-04-23", "updated_date": "2022-04-03", "body": "<p>&nbsp;</p>\r\n<p>Though we enjoy manufacturing and assembling&nbsp;<a href=\"http://www.cryosphereinnovation.com/simb3\">SIMB3s</a>, the fun really starts after they are installed into ice and collecting valuable data for you. After a quick flip of a switch during deployment, SIMB3 starts transmitting data which you can access immediately via our Real-Time Data Portal. Every SIMB3 has its own page, and from that page you can download the raw data as a CSV spreadsheet.asdcsadc</p>\r\n<h2>The datasheet explained</h2>\r\n<p>The SIMB3 datasheet is the permanent record of data transmission. It is a comma-separated value spreadsheet and is unique to each SIMB3. Every time the SIMB3 transmits, a row is added with the data from that transmission. Once a row is added, it will remain for the life of the instrument.</p>\r\n<h3>Naming scheme</h3>\r\n<p>The datasheet is always labeled &ldquo;SIMB3&rdquo; followed by an underscore and the instruments&rsquo; International Mobile Equipment Identity (IMEI) number (e.g., &ldquo;SIMB3_300434064123456&rdquo;). For redeployed instruments, an additional &ldquo;-2&rdquo; or &ldquo;-3&rdquo; is appended to the label, where the number indicates the redeployment. Note that the datasheet for redeployed buoys contains the entire record of transmission, including data from the past deployment.</p>\r\n<h3>Columns</h3>\r\n<p>The datasheet for a standard SIMB3 contains 209 columns that correspond to readings from each of the <a href=\"https://www.cryosphereinnovation.com/simb3-detailed-specs\">SIMB3 sensors</a>. Each column is labeled with a distinct header that is explained below.</p>\r\n<p><img class=\"image_resized\" style=\"width: 842px;\" src=\"https://nyc3.digitaloceanspaces.com/ci-webapp-space/media/django-summernote/2022-03-05/5ede2b9b-acea-4803-aee1-3ff1549c031b.gif\" height=\"425\"></p>\r\n<p><strong>Figure 1</strong>: In this GIF of a standard SIMB3 datasheet, columns containing data have been identified with green headers and columns with diagnostic information have been identified with orange headers.</p>\r\n<h3>Header labels</h3>\r\n<p>Moving left to right from the top of the datasheet, the headers are:</p>\r\n<p><code>wdt_counter</code></p>\r\n<p>This is a diagnostic counter that indicates if the SIMB3 computer has reset. It counts from 0 &ndash; 255 and then resets back to 0.</p>\r\n<p><code>program_version</code></p>\r\n<p>This is the version of the SIMB3 firmware.</p>\r\n<p><code>time_stamp</code></p>\r\n<p>This is the transmission timestamp in Universal Coordinated Time (UTC). <strong>The number is a Microsoft Excel serial date</strong> and can viewed in date form by highlighting the column in Excel and selecting &ldquo;date&rdquo;. For more information on converting this number back to a Unix timestamp, see our tutorial <a href=\"https://www.cryosphereinnovation.com/articles/simb3-python\">Visualizing SIMB3 data using Python</a>.</p>\r\n<p><code>latitude</code></p>\r\n<p>This is the latitude at the time of transmission, as reported by the onboard GPS. <strong>It has units of degrees</strong>.</p>\r\n<p><code>longitude</code></p>\r\n<p>This is the longitude at the time of transmission, as reported by the onboard GPS.<strong> It has units of degrees</strong>.</p>\r\n<p><code>air_temp</code></p>\r\n<p>This is the air temperature as reported by the DS18B20 air temperature sensor located inside the SIMB3 top-cap radiation shield. The height of the sensor is approximately 1.2 meters above freeboard. <strong>It has units of degrees Celcius</strong>.</p>\r\n<p><code>air_pressure</code></p>\r\n<p>This is the barometric pressure as reported by the vented barometer underneath the SIMB3 top-cap. The height of the sensor is approximately 1.2 meters above freeboard. <strong>It has units of mBar</strong>.</p>\r\n<p><code>bottom_distance</code></p>\r\n<p>This is the output from the bottom rangefinder, and represents the distance from the fixed location below the ice to the ice bottom surface. <strong>It has units of meters</strong>.</p>\r\n<p><code>water_temp</code></p>\r\n<p>This is the temperature of the water at the location of the bottom rangefinder, as recorded by the thermistor inside the bottom rangefinder. <strong>It has units of degrees Celsius</strong>.</p>\r\n<p><code>surface_distance</code></p>\r\n<p>This is the output from the surface rangefinder, and represents the distance from a fixed position above the ice to the ice or snow surface. <strong>It has units of meters.</strong></p>\r\n<p><code>aux</code></p>\r\n<p>These are auxiliary entries. They will be &ldquo;0&rdquo; for all standard-equipped SIMB3s.</p>\r\n<p><code>battery_voltage</code></p>\r\n<p>This is the voltage of the 18V SIMB3 battery.&nbsp;&nbsp;</p>\r\n<p><code>gps_satellites</code></p>\r\n<p>This is a diagnostic number that corresponds to the number of satellites that GPS was able to fix onto.</p>\r\n<p><code>iridium_signal</code></p>\r\n<p>This is a diagnostic number that corresponds to the strength of the Iridium signal during transmission.</p>\r\n<p><code>iridium_retries</code></p>\r\n<p>This is a diagnostic number that corresponds to the number of times of the Iridium modem tried to transmit to the Iridium network. In most cases, it is &ldquo;0&rdquo;.</p>\r\n<p><code>dtc_values</code></p>\r\n<p>These are the temperature values from the Bruncin high-spatial resolution digital temperature string.&nbsp;dtc_values_0 is the first value in the string (at the top of the buoy, in the air) and dtc_values_191 is the bottom of the string (typically in the water). <strong>The values are in degrees Celsius</strong>.</p>\r\n<h3>Datasheet quality control</h3>\r\n<p>The data in the SIMB3 datasheet is raw data, hot off the buoy and completely unfiltered and unmodified. On occasion, spurious values will occur and can be filtered out depending on your preferences. Often these values occur during the spring/summer when the buoy is melting out or experiencing external forces from ice dynamics.&nbsp;&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h2>Working with SIMB3 data</h2>\r\n<p>Though our Real-Time Data Portal gives you access to current conditions and time-series data for every SIMB3, you can get a much more detailed understanding of the data your SIMB3 has recorded by plotting it yourself. To help you with this, we&rsquo;ve created two tutorials in both <a href=\"https://www.cryosphereinnovation.com/articles/simb3-matlab\">Matlab</a> and <a href=\"https://www.cryosphereinnovation.com/articles/simb3-python\">Python</a>. In these tutorials, we walk through how to create a mass balance plot, which is just a figure that shows how ice and snow thickness and temperature change through time.</p>\r\n<p>&nbsp;</p>\r\n<p>If you are interested in creating your own applications or web pages with SIMB3 data, both the Time-Series and Growth &amp; Melt plots from the <a href=\"https://www.cryosphereinnovation.com/simb3/443910\">SIMB3 data page</a> can be embedded in any website with one line of code. We are also in the process of developing a REST API which will give access to SIMB3 data programmatically. If API access would be useful to you, let us know!</p>\r\n<p>&nbsp;</p>\r\n<h2>Resources</h2>\r\n<p><a href=\"https://app.cryosphereinnovation.com/tutorials/matlab/SIMB3sampleDataSheet.csv\">Sample SIMB3 Datasheet</a></p>\r\n<p><a href=\"../../simb3-tech-specs\">SIMB3 Technical Specifications Page</a></p>"}}, {"model": "documentation.documentation", "pk": 19, "fields": {"title": "New SIMB3 MicroCTD add-on", "slug": "simb3-ctd", "path": "articles/simb3-ctd", "status": "Published", "internal": false, "heading": "Add ocean salinity measurements to SIMB3", "featured": false, "featured_heading": "SIMB3 + CTD!", "image": "article_images/ctd_0NLeP6n.jpg", "image_attribution": null, "published_date": "2022-04-17", "updated_date": null, "body": "<p>As a partnership with the <a href=\"https://www.awi.de/en/\">Alfred Wegner Institute</a>, we've developed a prototype conductivity, temperature, and depth (CTD) package for SIMB3. This add-on collects the three main state variables required to calculate ocean salinity.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n<h2>Design Motivation and Constraints</h2>\n<p>A CTD add-on, or at least an electrical conductivity add-on, has been at the top of our most-requested feature list for at least two years. In the past, it&lsquo;s a challenge I&rsquo;ve avoided tackling because of the difficulty of sourcing parts that I felt would properly integrate into SIMB3. Commercially available CTD packages and components are often physically bulky, power-hungry, and extraordinarily expensive. Given the ethos of SIMB3 as a small form factor, low-power, and easily deployed instrument, I didn&rsquo;t feel that any off-the-shelf options would work well.&nbsp;</p>\n<p>A couple of things changed this last year. First, Christian Haas at AWI reinitiated the idea of adding conductivity measurements as he was interested in deploying several SIMB3s in the marginal ice zone during springtime conditions. His use case mainly involves determining relative changes in upper-ocean salinity, and is less about measuring the the absolute value of salinity to a high-degree of accuracy. Relaxing the need for oceanographic-grade accuracies opened up several options for us.</p>\n<p>The second change was my discovery of <a href=\"https://atlas-scientific.com/\">Atlas Scientific</a>, which is a NYC company that produces an amazing line of sensors/circuits that are primarily marketed to the hydroponics industry. All of their sensors are small, power-efficient, and their documentation is some of the best that I&rsquo;ve ever seen. On top of that, they offer support circuitry that integrates directly with Arduino, making electrical integration into SIMB3 straightforward. Considering the above, I decided to design our own CTD for SIMB3 using a combination of components from Atlas Scientific and&nbsp;<a href=\"https://www.adafruit.com/\">Adafruit</a>.</p>\n<h2>Sensor Selection</h2>\n<p>The sensors chosen for the package are the <a href=\"https://files.atlas-scientific.com/Mini_EC_K_1.0_probe.pdf\">K-1 Mini EC probe,</a> the <a href=\"https://files.atlas-scientific.com/A-10_analog_pressure_sensor.pdf\">A-10 Analog Pressure Transducer</a>, and the <a href=\"https://files.atlas-scientific.com/Micro_PT-1000_probe.pdf\">Micro PT-1000 Temperature Sensor</a>. Each were chosen based on a combination of their size, electrical requirements, and their accuracy and measurement range. The accuracies and resolutions are below.</p>\n<figure class=\"table\">\n<table style=\"height: 84px; width: 114.249%;\">\n<thead>\n<tr style=\"height: 19.5938px;\">\n<th style=\"width: 55.2448%; height: 19.5938px;\">Sensor</th>\n<th style=\"width: 22.0979%; height: 19.5938px;\">Accuracy</th>\n<th style=\"width: 22.6573%; height: 19.5938px;\">Reported Precision</th>\n</tr>\n</thead>\n<tbody>\n<tr style=\"height: 23.0703px;\">\n<td style=\"width: 55.2448%; height: 23.0703px;\">Atlas Scientific K-1 Mini EC probe</td>\n<td style=\"width: 22.0979%; height: 23.0703px;\">+/- 5 micro Siemens</td>\n<td style=\"width: 22.6573%; height: 23.0703px;\">1 micro Siemens</td>\n</tr>\n<tr style=\"height: 23.0703px;\">\n<td style=\"width: 55.2448%; height: 23.0703px;\">Atlas Scientific A-10 analog Pressure Transducer</td>\n<td style=\"width: 22.0979%; height: 23.0703px;\">+/- 10 mBar</td>\n<td style=\"width: 22.6573%; height: 23.0703px;\">1 Mbar</td>\n</tr>\n<tr style=\"height: 23.0781px;\">\n<td style=\"width: 55.2448%; height: 23.0781px;\">Atlas Scientific Micro PT-1000 Temperature Sensor</td>\n<td style=\"width: 22.0979%; height: 23.0781px;\">+/- 0.01 C</td>\n<td style=\"width: 22.6573%; height: 23.0781px;\">0.5 C</td>\n</tr>\n</tbody>\n</table>\n</figure>\n<p>Two of the three sensors are digital and thus integrated directly into our existing SIMB3 hardware through our I<sup>2</sup>C line. The pressure transducer required an additional analog-to-digital conversion step before it could be integrated. The reported precision of this sensor is dictated primarily by the ADC, which in this case is 16-bit.</p>\n<p>Now, you might be asking &ldquo;why do you need a pressure sensor when you&rsquo;re only doing &rsquo;moored&rsquo; measurements, i.e., not depth casts where pressure changes are significant?&rdquo;. Great question and there are two answers. 1) Christian wanted the ability to tell if SIMB3 shifted vertically during deployment, and 2) I thought it would be way cooler to make a MicroCTD rather than a MicroCT .</p>\n<h2>Hardware Design and Placement</h2>\n<p>The hardware used to mount the CTD components was modeled and 3D printed in PLA plastic. Within SIMB3, the package mounts at the bottom of the lower section and is sealed with potting compound to maintain the necessary waterproof barrier. Location at the bottom of the lower section places the package approximately 1.5 meters below freeboard (distance below the ice will obviously vary with ice thickness). The entire package fits in your hand and adds just a few hundred grams to the SIMB3 weight.&nbsp;&nbsp;<br>&nbsp;</p>\n<figure class=\"image\"><img src=\"https://nyc3.digitaloceanspaces.com/ci-webapp-space/media/django-summernote/2022-05-04/7c0e78cd-f875-420f-a730-a027da92c068.jpg\">\n<figcaption><strong>Figure 1: </strong>Location of the MicroCTD package at the bottom of the SIMB3 lower section as seen during assembly. The white plastic portions visible get potted to form a waterproof barrier.&nbsp;</figcaption>\n</figure>\n<h2>Data and Equipped Buoys</h2>\n<p>Addition of the MicroCTD adds three columns to the SIMB3 datasheet; CTD conductivity, CTD temperature, and CTD pressure (depth). The columns are represented with intuitive names as <code>ctd_conductivity</code>, <code>ctd_temperature</code>, and <code>ctd_pressure</code>, respectively. These are also the field names used for queries made through our REST API.&nbsp;</p>\n<p>Currently, there are three SIMB3s equipped with the first three MicroCTDs that we have ever built. The buoys are:</p>\n<ul>\n<li><a href=\"https://cryosphereinnovation.com/simb3/300434064564590/\">AWI 2022 #1</a></li>\n<li><a href=\"https://cryosphereinnovation.com/simb3/300434064565670\">AWI 2022 #2</a></li>\n<li><a href=\"https://cryosphereinnovation.com/simb3/300434064564600\">AWI 2022 #3</a></li>\n</ul>\n<p>&nbsp;They are set to deploy during Summer of 2022 and we are excited to see the data they return! Once they activate, data will be available instantly via their respective dashboards. I'll also note that these buoys are not equipped with our standard-issue Bruncin temperature string, so the datasheet will look much smaller than it normally does.</p>\n<h2>Limitations and Future Work</h2>\n<p>The development of the first-generation SIMB3 MicroCTD represents a long-awaited step forward for the SIMB3 program. Of course, we'll learn a lot about the survivability and reliability of this package once the above buoys are deployed, but I'm optimistic that it will go smoothly. Assuming they last, it will serve as an excellent validation of Atlas Scientific products for use in Arctic conditions. They offer a wide range of other sensors, including sensors for measuring pH, oxidation-reduction potential, and dissolved oxygen. All of these would easily integrate into SIMB3.&nbsp;</p>\n<p>I'll also note that while this package has currently (as of June 2022) only been installed on a non-standard SIMB3 (without a temperature string), it will work just as well on a fully-equipped SIMB3. Given the demand, this is something we can develop.&nbsp;</p>\n<p>&nbsp;</p>\n<div class=\"raw-html-embed\">&nbsp;</div>"}}, {"model": "documentation.documentation", "pk": 20, "fields": {"title": "REST API Documentation", "slug": "api-docs", "path": "articles/api-docs", "status": "Published", "internal": false, "heading": "Everything you need to know to access data and metadata using our public REST API", "featured": true, "featured_heading": null, "image": "article_images/rest_api_docs-01_bs027lP.png", "image_attribution": null, "published_date": "2022-06-03", "updated_date": null, "body": "<h2>Cryosphere Innovation REST API</h2>\r\n<p>The Cryosphere Innovation REST API provides the public with programmatic access to Cryosphere Innovation data and metadata in a fast, modern format. It is intended for use by scientists, engineers, and developers seeking to explore or consume data from Cryosphere Innovation-built assets deployed worldwide. The API allows you to make a wide range of queries, returning only the specific data you requested. Among many things, you can use it to build real-time data applications (like our <a href=\"https://www.cryosphereinnovation.com/simb3/300434065551610/\">SIMB3 Dashboard</a>), twitter-bots, or just to refine and compare data in our growing <a href=\"https://dev.cryosphereinnovation.com/data\">archive</a>.</p>\r\n<h3>Overview</h3>\r\n<p>We provide two API endpoints for public consumption of SIMB3 data. They are below:</p>\r\n<ul>\r\n<li>SIMB3 data @ <span style=\"color: rgb(154,168,58);\"><code>/api/simb3/data/</code></span></li>\r\n<li>SIMB3 metadata @ <code>/api/simb3/metadata</code></li>\r\n</ul>\r\n<p>As the names imply, the <span style=\"color: rgb(154,168,58);\"><code>/api/simb3/data/</code></span> endpoint returns raw SIMB3 data and <code>/api/simb3/metadata</code> returns SIMB3 metadata (like the name, deployment date, version, etc.). Both endpoints can be refined with <em>query parameters</em>, which are appended to the end of the URL and tell the API specifics about the information you're looking for. For example, the following request will return the air temperature from SIMB3 Dartmouth 2020 #3 (with IMEI <a href=\"tel:300434065551610\">300434065551610</a>).&nbsp;</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/data/?imei=300434065551610&amp;field=air_temp</code></p>\r\n<p>You can test this out by copying it into your browser (or by clicking <a href=\"https://www.cryosphereinnovation.com/api/simb3/data/?imei=300434065551610&amp;field=air_temp\">here</a>). If you're logged in, you'll see a page full of text with values like <code>{\"imei_fk\":300434065551610,\"time_stamp\":44444.83399305555,\"air_temp\":-8.3125}&hellip;</code>. If you're not logged in, you will get an authentication error. To use our API, you need to <a href=\"https://www.cryosphereinnovation.com/accounts/register\">make an account</a> and get an API token (under your account settings).&nbsp;</p>\r\n<p>The response you see is JSON format. JSON, which stands for Javascript Object Notation, is a standard string-based format for returning data from REST APIs. It is widely used across the web and all major coding languages will have packages for parsing JSON responses into usable data types (dictionaries in Python or objects in Javascript, for instance). For more information about JSON, check out <a href=\"https://restfulapi.net/introduction-to-json/\">this page</a>.</p>\r\n<h2>Formatting Queries</h2>\r\n<p>The query parameters which format the response from the API begin after the question mark in the request URL. In the above example, we are telling the API that we want the field <code>air_temp</code> from the SIMB3 with <code>imei=300434065551610</code>. This is a simple example, but it illustrates the power of this type of system. We can query any variable in the <a href=\"../getting-started-with-the-simb3-datasheet\">SIMB3 datasheet</a> and we can even chain fields. For instance, if we wanted to compare surface position with air temperature we could add <code>&amp;field=surface_distance</code> to our request. The API will then return the full time series of air temperature and surface distance for IMEI <a href=\"tel:300434065551610\">300434065551610</a>. The full request would look like</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/data/?imei=300434065551610&amp;field=air_temp&amp;field=surface_distance</code></p>\r\n<p>and the response will be a JSON with a bunch of rows like</p>\r\n<p><code>{\"imei_fk\":300434065551610,\"time_stamp\":44449.16739583333,\"air_temp\":-3.625,\"surface_distance\":1.133}</code>.</p>\r\n<p>There is no limit to the number of fields that you can make in a single query. Just chain them together with <code>&amp;</code>.&nbsp;</p>\r\n<blockquote>\r\n<p>If this seems funny or unclear, be comforted by the fact that you probably make hundreds of API requests every week, perhaps without even knowing it. Anytime you enter a search to Google, notice how the URL changes to include the words in your search. For instance, if you Google &ldquo;How do rest apis work&rdquo; &nbsp;the URL will change to &ldquo;https://www.google.com/search?q=how+do+rest+apis+work&rdquo;. The parameters after the question mark tell the Google backend what you're searching and it returns only information related to your search.</p>\r\n</blockquote>\r\n<h2>Data API Documentation</h2>\r\n<p>The full capabilities of the Cryosphere Innovation data API are documented in this section. To test or explore any of these endpoints, simply copy them into your browser or enter them into the terminal on our <a href=\"https://www.cryosphereinnovation.com/api\">API page</a>.&nbsp;</p>\r\n<h3>Requesting data for a single IMEI</h3>\r\n<p>To fetch data for a specific SIMB3, simply append an <code>imei=imei_you_want</code> to the query parameters, replacing <code>imei_you_want</code> &nbsp;with the full 15-digit IMEI of the SIMB3 you're interested in. By default (without any fields or other parameters specified) the API will return a JSON of the entire dataset. This response can be quite large (~5-10 MB), so it's typically better to ask the API for only the specific fields you're interested in.&nbsp;</p>\r\n<h4>Specifying Fields</h4>\r\n<p>Narrow your request to specific fields by adding <code>&amp;field=the_field_you_want</code> to your URL, replacing <code>the_field_you_want</code> with any field from the <a href=\"../getting-started-with-the-simb3-datasheet\">SIMB3 datasheet</a>. You can add one or multiple fields to create custom responses that give you only the data you desire. All fields in the SIMB3 datasheet are available for query, and they field names should be spelled exactly as they are in the SIMB3 datasheet. Note that URLs are case-sensitive, so <code>&amp;field=air_temp</code> is not the same as <code>&amp;field=Air_temp</code>. If you are interested in just the temperature string data, you can use <code>field=temp_string</code> instead of entering all 192 values manually.&nbsp;</p>\r\n<h4>Specifying Time Stamps or Day</h4>\r\n<p>If you want data from a specific time, append a <code>&amp;time_stamp=time_stamp</code> query parameter. The value of <code>time_stamp</code> must match the desired time stamp to full precision.&nbsp;</p>\r\n<p>Often time stamps are clunky to deal with, so you can also refine your query to a specific day using <code>&amp;day=yyyy-mm-dd</code>.&nbsp;</p>\r\n<p>To request just the most recent transmission, use the special value of <code>time_stamp=latest</code>. For instance, all fields during the most recent transmission for IMEI &nbsp;<code>300434065551610</code> can be fetched as:</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/data/?imei=300434065551610&amp;time_stamp=latest</code>.</p>\r\n<h3>Requesting data across IMEIs</h3>\r\n<p>Until now, the API response has only ever contained data from single buoys. However, one powerful feature of the data API is the ability to make requests across IMEIs. This allows you to make queries without knowing the specifics of the instruments you're looking for.&nbsp;</p>\r\n<p>Let's say you're working on a project analyzing upper ocean temperature data from instruments deployed in the Beaufort Sea. Rather than combing every buoy in our<a href=\"../../data\"> Data Portal</a> and downloading data individually, you can simply fetch all the data at once using a single API query with a tag:</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/data/?tag=beaufort_sea&amp;field=water_temp</code></p>\r\n<p>Note that unlike requesting data from a single IMEI, tag-based requests <strong>do not</strong> <strong>return any fields by default when no IMEI is specified</strong>. We do this on purpose, to prevent accidentally returning massive responses. You should instead directly specify the fields you need just as above.&nbsp;</p>\r\n<p>You can also chain tags. Say you want to get the ocean temperature values for Beaufort Sea buoys, but you only want the most recent values from SIMB3s that are currently active. That request would look like:</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/data/?tag=beaufort_sea&amp;tag=active&amp;field=water_temp&amp;time_stamp=latest</code></p>\r\n<p>You can chain any number of tags together along with any number of fields to refine your request to exactly what you need. If there aren't any buoys that satisfy your request, the response will simply come back empty.&nbsp;</p>\r\n<p>One note: tags are exclusive, not inclusive, meaning that a request with multiple tags will only return data for buoys that have both of those tags. As an example, a request with <code>&amp;tag=active&amp;tag=retired</code> will return nothing as it's impossible for a buoy to be both active and retired at the same time. If you'd like support for inclusive tag-based queries, let us know and we'll add it to our development list.&nbsp;</p>\r\n<h4>&nbsp;</h4>\r\n<h4>Full list of tags</h4>\r\n<p>All of these tags are available for query (this list is subject to change). For multiple-word tags, the space is replaced with an underscore.&nbsp;</p>\r\n<ul>\r\n<li><code>+1_year</code> SIMB3s that have been continuously operational for &gt;1 year.&nbsp;</li>\r\n<li><code>+_6_months</code> SIMB3s that have continuously operated for &gt; 6 months.</li>\r\n<li><code>redeployment</code> SIMB3s that have been deployed, recovered, and redeployed</li>\r\n<li><code>sidex</code>: SIMB3s that were deployed as a part of the SIDEx program. Note that this can span multiple years.&nbsp;</li>\r\n<li><code>dartmouth</code> SIMB3s that are funded and owned by affiliates at Dartmouth College in Hanover, New Hampshire.&nbsp;</li>\r\n<li><code>active</code> SIMB3s that are currently actively transmitting</li>\r\n<li><code>retired</code> SIMB3s that have been deployed and recovered, or have otherwise ceased transmitting.&nbsp;</li>\r\n<li><code>in_testing</code>: SIMB3s that are currently in testing.&nbsp;</li>\r\n<li><code>awaiting_deployment</code> new SIMB3s that are waiting to be deployed.</li>\r\n<li><code>landfast_ice</code> SIMB3s deployed in landfast ice.</li>\r\n<li><code>winter_deployment</code> SIMB3s deployed during winter.</li>\r\n<li><code>fall_deployment</code> SIMB3s deployed during fall.</li>\r\n<li><code>spring_deployment</code> SIMB3s deployed during spring.</li>\r\n<li><code>data_available</code> SIMB3s with publically downloadable data.</li>\r\n<li><code>collocated_instruments</code> SIMB3s deployed alongside other instruments.</li>\r\n<li><code>open_water_deployment</code> SIMB3s deployed in open water (through initial freeze-up).</li>\r\n<li><code>nsf_funded</code> SIMB3s funded by grants provided by the National Science Foundation.</li>\r\n<li><code>mosaic</code> SIMB3s deployed during the MOSAiC expedition in '19-20.</li>\r\n<li><code>beaufort_sea</code> SIMB3s deployed in the Beaufort Sea.</li>\r\n<li><code>central_arctic</code> SIMB3s deployed in the Central Arctic.</li>\r\n<li><code>antarctic</code> SIMB3s deployed in the Southern Hemisphere.</li>\r\n<li><code>ctd</code> SIMB3s equipped with our conductivity, temperature, and depth add-on.</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<h3>Requesting user-specific SIMB3s</h3>\r\n<p>If you have an account with us, you can add SIMB3s to your &ldquo;watched list&rdquo; which shows up on your dashboard. If you're doing research, this allows you to keep easy tabs on specific buoys that you're interested in. You can also refine your API queries to these specific buoys by adding the <code>domain=watched</code> query parameter:</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/data/?domain=watched</code></p>\r\n<p>If you have a customer account, you can restrict your query to only buoys you own or that you've been listed as a private user on. To do this use the <code>domain=user</code> query parameter.&nbsp;</p>\r\n<p><a href=\"https://cryosphereinnovation.com/api/simb3/data/?domain=user\"><code>https://www.cryosphereinnovation.com/api/simb3/data/?domain=user</code></a></p>\r\n<p>&nbsp;</p>\r\n<h4>Metadata API Documentation</h4>\r\n<p>Metadata is descriptive data. It tells us information about an SIMB3, such as where it was deployed and what sensors it's equipped with. Fetching metadata has many similarities to fetching regular data, except you need to use the metadata API endpoint:</p>\r\n<p><code>/api/simb3/metadata</code></p>\r\n<p>If you're doing research or beginning a project, you will probably want to start here. Like our data endpoint, our metadata endpoint supports single IMEI and multiple IMEI requests using tags. For instance, to query the metadata for all SIMB3 deployed on the MOSAiC cruise, you would use:&nbsp;</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/metadata/?tag=mosaic</code></p>\r\n<p>The response will contain many key-value pairs in JSON format describing each buoy in detail. Because metadata responses are generally much smaller, <strong>we do not currently support filtering by field</strong>. In other words, a request like</p>\r\n<p><code>https://www.cryosphereinnovation.com/api/simb3/metadata/?tag=mosaic&amp;field=status</code></p>\r\n<p>won't return anything. You would instead omit the field specifier and return the entire dictionary.</p>"}}, {"model": "documentation.documentation", "pk": 31, "fields": {"title": "Internal API docs", "slug": "internal-api-docs", "path": "articles/internal-api-docs", "status": "Draft", "internal": false, "heading": "Reference for the new (2023) Cryosphere web API", "featured": false, "featured_heading": null, "image": "article_images/arctic_sea_ice_min_2020.1410_print.jpg", "image_attribution": null, "published_date": null, "updated_date": null, "body": "<h1>Introducing our new API</h1>\r\n<p>With it you can&nbsp;</p>\r\n<h2>Deployments for any instrument </h2>\r\n<pre class=\"language-javascript\"><code>export default function Example(props){\r\nreturn('hello')\r\n}</code></pre>\r\n<pre class=\"language-matlab\"><code>x = 10;\r\ny = 5;\r\nz = x + y;\r\ndisp(z);\r\nvector = [1, 2, 3, 4, 5];\r\nplot(vector);</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Create an instrument -&gt; create a deployment -&gt; import data. DONE</p>\r\n<p>It's as easy as 1, 2,3&nbsp;</p>"}}, {"model": "documentation.documentation", "pk": 33, "fields": {"title": "MDX Article", "slug": "mdx", "path": "docs/mdx", "status": "Draft", "internal": false, "heading": "MDX article", "featured": false, "featured_heading": null, "image": "", "image_attribution": null, "published_date": null, "updated_date": null, "body": null}}]